## Using Outlines for LLM Constrained Generation

_October 2025_

Constrained generation is something that has interested me recently. Mostly as an extension of structured generation. For example in the newest `gpt-5` models you can now have Regex as a constrained output. Now [outlines](https://github.com/dottxt-ai/outlines) is not particularly new, though what is interesting to me is the design of their APIs. 

**Chat Templates**

Are created via:

```py
# Fill in nested templates
prompt = chat_template(
    system=system_template(instruction="You are a helpful assistant."),
    user=user_template(query="What is machine learning?")
)
```

**Constrained outputs**

...is as straightforward as:

```py
model(prompt, output_constraints)
```

These support `dataclasses`, `pydantic`, `Regex` and even `Literal[tuple(enums)]`.

Putting this together, we can attempt to get the LLM to play chess (albeit not very well). It does make me wonder how we may use LLMs to play games in a precise manner, e.g. if moves are injected in context to 'promote' them or dissuade an LLM from playing bad moves. 

```py
import random
import re
from typing import Literal

import chess
import chess.pgn
import outlines
import tabulate
from colorama import Fore, Style
from llama_cpp import Llama
from pydantic import BaseModel, Field

model = outlines.from_llamacpp(Llama(model_path="gpt-oss-20b-mxfp4.gguf"))


def print_board(board: chess.Board):
    unicode_board = board.unicode(empty_square="·")
    # change black to orange
    for piece in "♜♞♝♛♚♟":
        unicode_board = unicode_board.replace(piece, Fore.RED + piece + Style.RESET_ALL)
    for piece in "♙♖♘♗♕♔":
        unicode_board = unicode_board.replace(
            piece, Fore.LIGHTCYAN_EX + piece + Style.RESET_ALL
        )

    # add row numbers
    unicode_board = "\n".join(
        [f"{8 - i}   {line}" for i, line in enumerate(unicode_board.split("\n"))]
    )
    # add column letters
    unicode_board = (
        unicode_board
        + "\n\n    "
        + "".join(
            [f"{chr(97 + i)} " for i, line in enumerate(unicode_board.split("\n"))]
        )
    )
    # print(unicode_board)

    # pretty show the movelist
    game = chess.pgn.Game()
    game.add_line(board.move_stack)
    exporter = chess.pgn.StringExporter(headers=False, variations=False, comments=False)
    moves = game.accept(exporter)
    moves = moves.replace("\n", " ")

    # add a new line after each move number (e.g., "1.", "2.", etc.)
    moves = re.sub(r"(\d+\.)", r"\n\1", moves).strip()

    # take the last 10 moves only
    if len(moves.split("\n")) > 10:
        moves = "...\n" + "\n".join(moves.split("\n")[-9:])
    else:
        moves = moves

    # pretty print
    print(tabulate.tabulate([[unicode_board, moves]]))
    return unicode_board


class MoveInfo:
    uci: str
    description: str
    piece_hash: str
    san: str
    root_sq: str
    root_piece: str

    def __init__(self, board: chess.Board, move: chess.Move):
        self.uci = move.uci()
        self.san = board.san(move)
        self.root_sq = move.uci()[0:2]
        self.root_piece = self.san[:-2]
        self.piece_hash = self.compute_piece_hash()
        self.description = self.get_description()

    def compute_piece_hash(self) -> str:
        if len(self.root_piece) < 1:
            return ""

        if self.root_piece[0].isupper():
            return self.root_piece[0] + self.root_sq
        else:
            return ""

    def get_description(self) -> str:
        move_type = "capture" if "x" in self.san else "move"
        if len(self.root_piece) < 1 or self.piece_hash == "":
            return f"{self.san} - desc: pawn {move_type}"
        else:
            return f"{self.san} - desc: {self.root_piece[0]} {move_type}"

    def __repr__(self) -> str:
        return f"<MoveInfo: {self.description}>"


def sample_moves(legal_moves: list[MoveInfo]):
    # sample by piece_hash, return only 1 move per piece_hash
    moves_by_hash = {}
    for move in legal_moves:
        moves_by_hash[move.piece_hash] = moves_by_hash.get(move.piece_hash, []) + [move]

    sampled_moves = []
    for hash, moves in moves_by_hash.items():
        if len(moves) > 1:
            sampled_moves.append(random.choice(moves))
        else:
            sampled_moves.append(moves[0])
    return sampled_moves


def create_chess_moves_class(
    legal_moves: list[MoveInfo], sampled_moves: list[MoveInfo]
):
    # Dynamically creates a class for sentence classification scores with the given score attributes.

    class LegalMoves(BaseModel):
        move: str = Field(
            description=f"The move to make. For example:\n\n{sampled_moves}",
            json_schema_extra={"enum": [move.san for move in legal_moves]},
        )

    return LegalMoves


def do_turn(board: chess.Board, assistant_prompt: str):
    legal_moves = [MoveInfo(board, x) for x in board.legal_moves]
    sampled_moves = sample_moves(legal_moves)
    sampled_moves_description = "\n".join([move.description for move in sampled_moves])

    # # using pydantic
    # outcome = model(
    #     assistant_prompt + f". Board:\n\n{board}\n\nFEN: \n\n{board.fen()}\n\nSample moves:\n\n{sampled_moves_description}",
    #     create_chess_moves_class(legal_moves, sampled_moves)
    # )
    # import json
    # legal_moves = [move for move in legal_moves if move.san == json.loads(outcome)['move']]

    # using typing.literal
    legal_move_strings = [move.san for move in legal_moves]
    LegalMoveLiteral = Literal[tuple(legal_move_strings)]
    outcome = model(
        assistant_prompt
        + f". Board:\n\n{board}\n\nFEN: \n\n{board.fen()}\n\nSample moves:\n\n{sampled_moves_description}",
        LegalMoveLiteral,
    )
    legal_moves = [move for move in legal_moves if move.san == outcome]

    if len(legal_moves) == 0:
        raise ValueError(f"Illegal move: {outcome.move}")
    else:
        legal_move = legal_moves[0]

    # make the move
    board.push(chess.Move.from_uci(legal_move.uci))
    return outcome


def play_chess(board: chess.Board):
    white_prompt = "You are a snarky chess bot. You are given a board and sample moves. You need to choose the best move, and provide some trash talking, as a sassy young girl."
    black_prompt = "You are a friendly chess bot. You are given a board and sample moves. You need to choose the best move, and provide some encouraging words, as a friendly old man."
    prompt = white_prompt if board.turn == chess.WHITE else black_prompt
    return do_turn(board, prompt)


# the object is dynamically generated since the enum changes all the time
board = chess.Board()

while board.outcome() is None:
    print_board(board)
    play_chess(board)

print_board(board)
print(board.outcome())

game = chess.pgn.Game()
game.add_line(board.move_stack)
```
