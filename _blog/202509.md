## In Appreciation of Go Generate

_September 2025_

Go is a rather minimal language. It does away with macros and (direct)
metaprogramming, but it does offer code generation as a first-class citizen via
`go:generate` . On multiple counts, it is rather unassuming and underwhelming,
after all the code generation needs to be directly committed for it to be used;
there's no generators or run time generation, but rather it forms part of the
distribution.

In a sense, this ends up being a _feature_ of Go, specifically how it
_implicitly_ does imports compared with other languages like Python. For
example, if a source file defines a method, then that method is exposed
everywhere within the scope of that package. More specifically it does **not**
need to be explicitly imported. This facet of Go compliments and perhaps even
encourages the use of code generation.

For example, if you want to extend [`sqlc`](https://sqlc.dev/) to use a code
generator, you can then naively extend the `Querier` interface in a separate
file. For example, your file tree could look like:

```
├─ querier.go
├─ querier_custom.go
```

Where your source code in `querier_custom.go` in its _totality_ would just look
like

```go
package sqlc

import (
    "context"
)

type CustomQuerier interface {
    Querier
    
    MyCustomMethod(ctx context.Context, ...) (...)
}

var _ CustomQuerier = (*Queries)(nil)
```

The interface will automatically compose itself, which is different to how
Python might do it in OOP way

```py
from querier import Querier

class CustomQuerier(Querier):
    ...
```

I think this _implicit_ namespace inclusion in Go is what makes code generation
work so well. At the same time there are draw-backs with regards to codebase
navigation. It leads to the lots of (automated) code that is directly in the
codebase, rather than having it hidden away in a macro. This affects the
readability of a codebase and ability to navigate it without an IDE. In my
exposure to Go code, I find the code very difficult to navigate using the web
interface. It is difficult to 'guess' where a method may be defined (it can
literally be anywhere!). In comparison in languages like Python/Rust, imports
are explicitly stated, meaning that one can navigate the codebase without
relying on IDE/LSP functionality.

Overall this kind of setup in many ways make Go code approachable, in the sense
that there's no 'knowledge' one needs to have when tackling a new codebase.
Everything is laid bare for you to follow. From a personal perspective, I
believe it is something to acknowledge and appreciate. It is this simplicity
that allows one to walk away from a Go codebase and come back to it years down
the track and just pick it up again.
